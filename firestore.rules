/**
 * @file Firestore Security Rules
 * @description This ruleset focuses on securing a wedding website's Firestore database.
 *
 * Core Philosophy:
 *  - Guests can only manage their own RSVP data.
 *  - Photos are publicly readable based on a 'slug' field, with no write access through rules.
 *  - Venues and site configurations are publicly accessible, without write permissions handled by rules.
 *
 * Data Structure:
 *  - /guests/{guestId}: Stores individual guest information.
 *  - /photos/{photoId}: Stores photo metadata, meant for public display based on the 'slug' field.
 *  - /venues/{venueId}: Stores venue details.
 *  - /site_configuration/config: Stores a single document with site-wide settings.
 *
 * Key Security Decisions:
 *  - Guest data is strictly user-owned; guests can only read and write their own data.
 *  - Public photo access is controlled via the 'slug' field, with write access managed elsewhere.
 *  - Listing of guests, photos, venues is allowed for all users.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to guest data, ensuring guests can only manage their own information.
     * @path /guests/{guestId}
     * @allow (create, update, delete) - Authenticated user with UID matching the guestId can create, update, or delete their own guest data.
     * @allow (get, list) - Authenticated user with UID matching the guestId can read their own guest data.
     * @deny (create, update, delete) - Authenticated user attempts to modify another guest's data.
     * @principle Enforces document ownership for writes and restricts access to a user's own data tree.
     */
    match /guests/{guestId} {
      allow get: if isSignedIn();
      allow list: if true;
      allow create: if isSignedIn() && request.auth.uid == guestId;
      allow update: if isSignedIn() && isExistingOwner(guestId) && request.auth.uid == guestId;
      allow delete: if isSignedIn() && isExistingOwner(guestId) && request.auth.uid == guestId;
    }

    /**
     * @description Controls access to photo data, allowing public read access based on the 'slug' field.
     * @path /photos/{photoId}
     * @allow (get, list) - Any user can read photo data if the 'slug' matches "mely-y-noe".
     * @deny (create, update, delete) - All users are denied write access through rules. Write operations are expected to be handled server-side or restricted by other mechanisms.
     * @principle Allows public read access to photos while restricting write access.
     */
    match /photos/{photoId} {
      allow read: if resource.data.slug == "mely-y-noe";
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to venue data, allowing public read access.
     * @path /venues/{venueId}
     * @allow (get, list) - Any user can read venue data.
     * @deny (create, update, delete) - All users are denied write access through rules. Write operations are expected to be handled server-side or restricted by other mechanisms.
     * @principle Allows public read access to venues while restricting write access.
     */
    match /venues/{venueId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to site configuration data, allowing public read access. Only a single document exists in this collection.
     * @path /site_configuration/config
     * @allow (get) - Any user can read the site configuration data.
     * @deny (create, update, delete, list) - All users are denied write access through rules. Write operations are expected to be handled server-side or restricted by other mechanisms.
     * @principle Allows public read access to site configuration while restricting write access.
     */
    match /site_configuration/config {
      allow get: if true;
      allow list: if false;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
        return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}